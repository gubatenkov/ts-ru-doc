# Примитивные типы Number, String, Boolean, Symbol, BigInt

Преобразования _TypeScript_ не затронуло ни один из перечисленных в заголовке тип. Но несмотря на это их упоминание необходимо, поскольку их отсутствие сделало бы картину менее точной.


## Важно

Помимо того, что система типов _TypeScript_ включает в себя все существующие в _JavaScript_ типы данных, некоторые из них подверглись более очевидному уточнению.

Типы данных, чьи идентификаторы начинаются с прописной буквы (`Type`), представляют _объектные типы_ (ссылочные типы) описывающие одноимённые типы из _JavaScript_ (`Number`, `String`, `Boolean` и т.д.). Проще говоря типы знакомые по _JavaScript_ и начинающиеся с большой буквы представляют конструкторы. В _TypeScript_ подобные типы описаны с помощью глобальных интерфейсов (`interface`) и помимо того, что их можно расширять (`extends`) и реализовывать (`implements`) их также можно указывать в аннотации типа. Но сразу стоит сделать акцент на том, что указывать их в аннотации следует только тогда, когда подразумевается именно конструктор. Для остальных случаев существуют типы идентификаторы которых начинаются со строчной буквы (`type`). Имена типов начинающихся с маленькой буквы являются зарезервированными ключевыми словами и представляют литералы примитивных значений, то есть непосредственно числа, строки и другие значения. Данные типы предназначены для указания в аннотациях, а не для использования в механизмах, как например наследование или расширение.


## Number (number) примитивный числовой тип

В _TypeScript_, как и в _JavaScript_, все производные от `number` являются 64-битными числами двойной точности с плавающей запятой. 

Помимо того, что в _TypeScript_ существует тип `Number` представляющий конструктор одноименного типа из _JavaScript_, также существует тип `number` представляющий примитивные значения числовых литералов.

`````ts
let v1: number; // v1: number явно
let v2 = 5.6; // v2: number неявно
`````

Напомню, что числа могут записываться в двоичной, восьмеричной, десятичной, шестнадцатеричной системе счисления.

`````ts
let binary: number = 0b101;
let octal: number = 0o5;
let decimal: number = 5;
let hex: number = 0x5;
`````

Помимо этого тип `number` неявно преобразуется в тип `Number`, но не наоборот.

```ts
let n: number = 5;
let N: Number = new Number(5);

N = n; // Ok
n = N; // Error -> Type 'Number' is not assignable to type 'number'.
```

В случаях когда тип не указан явно, а в качестве значения ожидается результат вызова конструктора, то вывод типов определяет принадлежность к типу конструктора только если конструктор был вызван при помощи оператора `new`.

```ts
let v0 = Number(5); // let v0: number
let v1 = new Number(5); // let v1: Number
```

В _TypeScript_ поведение типа `Number` идентично поведению одноимённого типа в _JavaScript_.


## String (string) примитивный строковый тип

Примитивный тип `String` представляет собой последовательность символов в кодировке _Unicode_ _UTF-16_. Строки могут быть заключены в одинарные или двойные кавычки, а также в обратные апострофы (инициаторы так называемых шаблонных строк).

Помимо того, что в _TypeScript_ существует тип `String` описывающий одноименный конструктор из _JavaScript_, также существует тип `string` представляющий примитивные значения строковых литералов.

```ts
let v1: string; // v1: string явно
let v2 = 'Bird'; // v2: string неявно
let v3: string = "Fish"; // v3: string явно
let v4: string = `Animals: ${v2}, ${v3}.`; // v4: string явно
```

Тип `string` неявно преобразуется в тип `String`, но не наоборот.

```ts
let s: string = "";
let S: String = new String("");

S = s; // Ok
s = S; // Error -> Type 'String' is not assignable to type 'string'.
```

И кроме этого вывод типов выводит принадлежность к типу конструктора только если он был вызван с помощью оператора `new`.

```ts
let v0 = String(""); // let v0: string
let v1 = new String(""); // let v1: String
```

В _TypeScript_ поведение типа `String` идентично поведению одноимённого типа в _JavaScript_.


## Boolean (boolean) примитивный логический тип

Примитивный тип `Boolean` является логическим типом и представлен значениями "истина" `true` и "ложь" `false`. 

Помимо того, что в _TypeScript_ существует тип `Boolean` представляющий одноименный конструктор из _JavaScript_, также существует тип `boolean` представляющий примитивные значения логических литералов.

`````ts
let isV1Valid: boolean; // явно
let isV2Valid = false; // неявно
`````

Тип `boolean` неявно преобразуется в тип `Boolean`, что делает его совместимым с ним, но не наоборот.

```ts
let b: boolean = true;
let B: Boolean = new Boolean(true);

B = b; // Ok
b = B; // Error -> Type 'Boolean' is not assignable to type 'boolean'.
```

И кроме этого вывод типов выводит принадлежность к типу конструктора только если он был вызван с помощью оператора `new`.

```ts
let v0 = Boolean(""); // let v0: boolean
let v1 = new Boolean(""); // let v1: Boolean
```

В _TypeScript_ поведение типа `Boolean` идентично поведению одноимённого типа в _JavaScript_.


## Symbol (symbol) примитивный символьный тип

Примитивный тип `Symbol` предоставляет уникальные идентификаторы, которые при желании могут использоваться в качестве индексируемых членов объекта. 

Помимо того, что в _TypeScript_ существует тип `Symbol` описывающий одноименный конструктор из _JavaScript_, также существует тип `symbol`, представляющий примитивные значения литералов.

`````ts
let v1: symbol; // v1: symbol явно
let v2 = Symbol('animal'); // v2: symbol неявно
`````


Тип `symbol` неявно преобразуется в тип `Symbol`, что делает его совместимым с ним, но не наоборот.

```ts
let s: symbol = Symbol.for("key");
let S: Symbol = Symbol.for("key");

S = s; // Ok
s = S; // Error -> Type 'Symbol' is not assignable to type 'symbol'.
```

Поскольку конструктор `Symbol` нельзя вызвать с помощью оператора `new` вывод типов всегда будет определять принадлежность к типу `symbol`.
И кроме этого вывод типов выводит принадлежность к типу конструктора только если он был вызван с помощью оператора `new`.

```ts
let v0 = Symbol(""); // let v0: symbol
```

Тип `symbol` предназначен для аннотирования символьных литералов. В _TypeScript_, поведение типа `Symbol` идентично поведению одноимённого типа в _JavaScript_.


## BigInt (bigint) примитивный числовой тип

`BigInt` — примитивный числовой тип позволяющий безопасно работать с числами произвольной точности, в том числе значениями выходящими за пределы установленные типом `Number`. Примитивный тип `BigInt` указывается с помощью ключевого слова `bigint`.

`````ts
let bigInt: bigint = BigInt(Number.MAX_VALUE) + BigInt(Number.MAX_VALUE);
`````

Но стоит заметить, что на данный момент (конец 2018 года) из-за плохой поддержки типа `BigInt` _TypeScript_ позволяет работать с ним лишь при установленной опции компилятора `--target` в значение `ESNext`.

Тип `bigint` предназначен для аннотирования числовых значений с произвольной точностью. В _TypeScript_ поведение типа `BigInt` идентично поведению одноимённого типа в _JavaScript_.

