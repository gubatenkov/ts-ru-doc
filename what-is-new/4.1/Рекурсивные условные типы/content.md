## Рекурсивные условные типы

При разработке программ часто возникают потребности в создании значений при помощи рекурсии в основе которой лежит логическое условие. 

`````ts 
function flat(value){
    if(Array.isArray(value)){ // логическое условие
        return value.reduce((result, current) => [
            ...result, 
            ...flat(current)
        ], []);
    }

    return [value];
}

flat([0, [1, [2]], 3]); // [0, 1, 2, 3]
````` 

Но до текущего момента описать подобную логику с помощью типов было практически невозможно. Поэтому начиная с текущей версии _TypeScript_ делает послабления на установленные правила относительно рекурсивных типов. 

`````ts
type GetItemType<T> = T extends ReadonlyArray<infer U> ? GetItemType<U> : T;

declare function flat<T extends readonly unknown[]>(value: T): GetItemType<T>[];


let result = flat([0, [1, [2]], 3]); // let result: number[] = [0, 1, 2, 3]
`````

Но рекурсивные типы необходимо использовать крайне осторожно, поскольку помимо нагрузки на процессор, при больших объемах данных, данный механизм может из-за превышения максимальной вложенности объектов, привести к исключению во время компиляции. В общем лучше вообще не использовать этот механизм, чем создавать с его помощью универсальные типы способные покрыть все возможные случаи. Снимайте нагрузку зха счет определения типов максимально соответствующих каждому конкретному случаю.

