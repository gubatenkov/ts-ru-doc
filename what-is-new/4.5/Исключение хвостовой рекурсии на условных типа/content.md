## Исключение хвостовой рекурсии на условных типа

Безусловно, рекурсивные типы значительно упращают написание кода, но из-за ограничений связанных с бесконечным циклом не могут показать себя полность.
Представьте, что необходимо создать тип, который будет удалять крайние пробелы у литерального строкогого типа.

`````ts
type TrimLeft<T extends string> =
    T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;

type Test = TrimLeft<"  text">; // type Test = "text"
`````

Это очень простая задача, но реализуема только при условии ограниченной последовательности повторения пробелов. Простыми словами, если рекурсивная операция определение пробелов привысит установленный компилятором лимит, то возникнет ошибка.

`````ts
type TrimLeft<T extends string> =
    T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;

/**
 * До текущей версии [*] ошибка ->
 * Type instantiation is excessively deep and possibly infinite.ts(2589)
 */
type Test = TrimLeft<"                                                text">; // [*]
`````

Стоит заметить, что данный пример реализует так называемую _хвостовую рекурсию_, которая только возвращает результат и ничего с ним не делает. Поскольку в подобных случаях не требуется создание промежуточных результатов, нчиная с текущей версии, _TypeScript_ вводит оптимизацию позволяющую нашему примру быть работоспособным.

`````ts
type TrimLeft<T extends string> =
    T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;

/**
 * Начиная с текущей версии [*] Ok!
 */
type Test = TrimLeft<"                                                text">; // [*]
`````
