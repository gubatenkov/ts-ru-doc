## \[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ\] Изменение поведения для оператора Non-Null при совместном использовании с оператором опциональной цепочки

После того, как начиная с версии `3.7` был реализован оператор опциональной последовательности (`.?`), функционал определенный стандартом _ESMAScript_, многие обратили внимание на нелогичность его поведения при совместном использовании с таким оператором, как `Not-Null\Not-Undefined`.

`````ts
type T = {
    f0?: {
        f1?: any;
    }
}

function f(p?:T){
    p?.f0!.f1;
}

f({});
`````

Как известно, оператор опциональной последовательности предполагает предотвращение выполнения цепочки вызовов и поскольку в коде выше в функцию `f` передается объект лишенный хоть каких-то опциональных признаков типа `T`, то ошибки при обращении к полю `f1` через нулевую ссылку ассоциированную с полем `f0` не произойдет.

То есть предполагается, что подобный код после компиляции примет следующий вид -

`````js
function f(p){
    /**
     * Обращение к f1 произойдет только в случае
     * существования параметра p и определения в
     * нем поля f0 ссылающегося на объект.
     *//
    p === null || p === void 0 ? void 0 : p.f0.f1;
}

`````

И это логично!

Но до текущей версии подобный код разворачивался таким образом, что приводило к ошибке во время выполнения.

`````js
function f(p){
    /**
     * Обращение к f1 произойдет даже в случае
     * если параметр p и\или поле f1 отсутствует,
     *, что приведет к ошибке во время выполнения.
     * Кроме того, подобное поведение в корне противоречит
     * ожидаемому разработчиком поведению оператора
     * опциональной последовательности.
     */
     (p === null || p === void 0 ? void 0 : p.f0).f1;
}

`````

Исходя из этого начиная с версии `3.9` поведение оператора `Not-Null\Not-Undefined` используемого совместно с оператором опциональной цепочки было изменено на ожидаемое. В случае необходимости получения поведения предшествующего текущей версии предлагается конкретизировать выражение с помощью фигурных скобок.

`````ts
type T = {
    f0?: {
        f1?: any;
    }
}

function f(p?:T){
    /**
     * Указываем, что обращение к полю f1
     * должно произойти независимо от результата
     * выражения в круглых скобках.
     * 
     * После компиляции данный код примет подобный вид -
     * 
     * (p === null || p === void 0 ? void 0 : p.f0).f1;
     */
    (p?.f0)!.f1;
}

f({});
`````
