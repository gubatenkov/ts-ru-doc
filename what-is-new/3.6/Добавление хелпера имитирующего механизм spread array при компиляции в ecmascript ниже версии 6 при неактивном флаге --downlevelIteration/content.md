## Добавление хелпера имитирующего механизм spread array при компиляции в ecmascript ниже версии 6 при неактивном флаге --downlevelIteration
Начиная с версии `v3.6`, хелпер, генерирующийся при компиляции такой конструкции, как `array spread ([...Array(5)])`, в ECMAScript ниже 6 версии, при неактивном флаге `--downlevelIteration`, претерпел кардинальные изменения. Но обо всем по порядку.

До `TypeScript` версии `v3.6` при компиляции кода в версию ниже `es6`, для имитации механизма `spread` применённого к массиву, генерировался код объединяющий массивы с помощью его метода `.concat()` -

`````ts
let array = [0, 1, ...[2, 3]]; // этот код es6+ компилировался в..
var array = [0, 1].concat([2, 3]); // ..этот es5 код
```

Но имитация подобным образом не соответствует поведению предполагаемого спецификацией `es6` при использовании массива созданного с помощью конструктора, которому при вызове передали в качестве единственного аргумента числовое значение.

`````ts
let array = [0, 1, ...Array(3), 2, 3]; // этот код es6+ компилировался в..
var array = [0, 1].concat(Array(2), [2, 3]); // ..этот es5 код
```

Получение экземпляра массива подобным образом приводит к созданию объекта массива с заданной длиной, равной значению переданного в качестве аргумента, а также полным отсутствием элементов и следовательно ассоциированных с ними ключей (индексов массива).

`````ts
Array(3); // [empty × 3]

['a', 'b', 'c']; // ['a', 'b', 'c']

/**
 * У объекта массива созданного с помощью конструктора
 * длина равна переданному аргументу, то есть 3, но
 * ключи представляющие индекс массива, также как и
 * элементы - отсутствуют.
 */
Array(3); // псевдо объект массива {length: 3}

/**
 * У объекта массива созданного с помощью литерала массива
 * длина равняется количеству его элементов, то есть 3, а также
 * существуют ключи (0, 1, 2) ассоциированные с элементами ('a','b','c').
 */
['a', 'b', 'c']; // псевдо объект массива {length: 3, 0: 'a', 1: 'b', 2: 'c'}
```

Не будет лишним напомнить, что элементы у массива созданного с помощью конструктора буквально полностью отсутствуют, а не имеют значение `undefined`, как может показаться. При обращении к элементам по индексу входящего в диапазон установленного его длиной, `undefined` возвращается не потому, что хранится в качестве элемента, а потому, что `undefined` возвращается всегда при обращении к несуществующему ключу объекта.

`````ts
// случай с объектом созданного при помощи литерала

({ prop: 'value' }['prop']); // value - обращение к существующему ключу prop
({}['prop']); // undefined - обращение к не существующему ключу prop

// случай с массивом созданного при помощи литерала

['a', 'b', 'c'][0]; // a - обращение к существующему ключу 0
['a', 'b', 'c'][10]; // undefined - обращение к не существующему ключу 10

// случай с массивом созданного при помощи конструктора

Array(3)[0]; // undefined - обращение к не существующему ключу 0
```

Отсутствие ключей является причиной несоответствия количества реальных итераций и длины массива при работе с ними. Методы массива (`.forEach()`, `.map()` и др.) и итерирующие конструкции (`for...in\for...of`)проверяют ключи с помощью метода `.hasOwnProperty(key)` доставшегося по наследству от базового типа `Object`.

`````ts
/**
 * псевдо объект массива {length: 3}
 * Нет ключей - нет итераций!
 * Вывод в консоль: (пусто)
 */
Array(3).forEach(() => console.log(`iteration`));

/**
 * псевдо объект массива {length: 3}
 * Нет ключей - нет итераций!
 * Вывод в консоль: (пусто)
 */
for (let item of Array(3)) {
    console.log(`iteration`);
}
```

Тем не менее при применении механизма `spread` к массиву в `es6+` создает несуществующие элементы и заполняет их значениями `undefined`.

`````ts
/**
 * Длина === 7, количество итераций === 7
 */
[1, 2, ...Array(3), 3, 4]; // es6 - [1, 2, undefined, undefined, undefined, 3, 4]
```

Но скомпилированный `TypeScript` в `es < v6` код при неактивном флаге `--downlevelIteration`, до версии `v3.6` не соответствовал этому поведению, поскольку не преобразовывал отсутствующие элементы в элементы ассоциированные со значением `undefined`.

`````ts
/**
 * Длина === 7, количество итераций === 4!
 */
[1, 2, ...Array(3), 3, 4]; // es6 синтаксис компилировался в..
[1, 2].concat(Array(3), [2, 3]); // в es5 подобный код - [1, 2, empty × 3, 2, 3]
```

После того, как комьюнити обратило внимание на несоответствие в поведении, подход с нативным методом `.concat()` заменили на генерацию хелпера `__spreadArrays(array)` и тем самым исправили поведение на предполагаемое спецификацией. Отказ от нативного `.concat()` замедлил сказался на производительности, снизив её ровно в два раза.
