##Улучшение механизма проверки избыточных полей в объединённых типах (Union types)

В _TypeScript_ есть механизм называемый _проверкой избыточности свойств_ (_excess property checking_), который призван выявлять опечатки в литералах объекта.

`````ts
type RectCssStyle = {
    width: string;
    height: string;

    color?: string;
};

let graphics: RectCssStyle = {
    width: '24px',

    height: '24px',
    colour: 'red', // Error
};
```

С этим механизмом связанно два неоднозначных момента. Первый момент заключается в том, что в _TypeScript_, в некоторых случаях, избыточность допускается. Один из таких случаев является присвоение идентификатору, ассоциированного с типом Union, значения принадлежащего одновременно ко всем типам определяющих это объединение.

`````ts
// до версии v3.5

type CoordXY = {
    x: number;
    y: number;
};

type CoordZ = {
    z: number;
};

/**
 * По логике, в данном объекте, либо поля xy либо поле z являются излишними,
 * так как тип Union одновременно представляет лишь один определяющий
 * его тип данных
 */
const coords: CoordXY | CoordZ = {
    x: 0,
    y: 0,

    z: 0,
};
```

Второй неоднозначный момент сокрыт в реализации описанного выше поведения, которая даже не предусматривает проверку типов для полей являющихся излишними.

`````ts
// до версии v3.5

type CoordXY = {
    x: number;
    y: number;
};

type CoordZ = {
    z: number;
};

// вывод типов считает, что значение принадлежит к типу CoordXY
const coordsFirst: CoordXY | CoordZ = {
    x: 0,
    y: 0,
    z: '', // Ok, несмотря на то, что тип определен как number при присваивании значения принадлежащего к типу string ошибки не возникает
};

// вывод типов считает, что значение принадлежит к типу CoordZ
const coordsSecond: CoordXY | CoordZ = {
    x: '', // Ok...
    y: '', // Ok, несмотря на то, что тип определен как number при присваивании значения принадлежащего к типу string ошибки не возникает
    z: 0,
};
```

Это поведение кажется нелогичным, поэтому Начиная с версии _TypeScript_ `v3.5` частично было изменено. Теперь при проверке литералов объекта выполняется проверка типов, что устраняет второй неоднозначным случай.

`````ts
// начиная с v3.5

type CoordXY = {
    x: number;
    y: number;
};

type CoordZ = {
    z: number;
};

const coordsFirst: CoordXY | CoordZ = {
    x: 0,
    y: 0,
    z: '', // Error
};

const coordsSecond: CoordXY | CoordZ = {
    x: '', // Error
    y: '', // Error
    z: 0,
};
```

Тем не менее, нужно помнить, что первый случай, который также быд обозначен как не совсем очевидный, остался.

`````ts
// ...

const coords: CoordXY | CoordZ = {
    x: 0,
    y: 0,
    z: 0,
}; // Ok
```
