## [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Неограниченные генерики больше не совместимы с {}

До этого неограниченные параметры типа были совместимы с типом `{}`.

`````ts
function f<T> ( p: T ) {
    let a: {} = p; // (раньше) Ok
}
`````

Это поведение было причиной возникновения различного рода казусов.

`````ts
function toKeys ( object: {} ) {
    Object.keys( object );
}

function f<T> ( p: T ) {
    let keys = toKeys( p ) // (раньше) Ok, но ошибка вовремя выполнения программы поскольку в функцию toKeys может
                           // попасть undefined
}

f( undefined ); // ломаем программу передав undefined
`````

В связи с этим поведение было изменено.

`````ts
function f<T> ( p: T ) {
    let a: {} = p; // (раньше) Ok (теперь) Error -> Type 'T' is not assignable to type '{}'.(2322)
}
`````

Для сохранения логики при новом поведении необходимо явно ограничить параметр типа..

`````ts
function f<T extends {}> ( p: T ) {
    let a: {} = p; // (раньше) Ok (теперь) Ok
}
`````

..не допустить принадлежность к `null` или `undefined` при помощи условия..

`````ts
function f<T> ( p: T ) {
    if( p === null || p === undefined ){
        return;
    }
    
    let a: {} = p; // (раньше) Ok (теперь) Ok
}
`````
..или в случае уверенности в наличии значения прибегнуть к помощи ненулевого утверждения (`x!`).

`````ts
function toKeys ( object: {} ) {
    Object.keys( object );
}

function f<T> ( p: T ) {
    let keys = toKeys( p! ) // (раньше) Ok (теперь) Ok
}
`````
